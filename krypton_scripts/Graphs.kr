{
    def newEdge(source, destination, weight) {
        return {"source" : source, "dest" : destination, "weight" : weight};
    }

    def minCost_Kruskal(edgeList, nVertices) {

        def swap(lst, i, j) {
            temp = lst[i];
            lst[i] = lst[j];
            lst[j] = temp;
        }

        def sort(edgeList, func) {
            for(i = 0; i < len(edgeList); i = i + 1) {
                for(j = 1; j < len(edgeList); j = j + 1) {
                    if(func(edgeList[j], edgeList[j - 1])) {
                        swap(edgeList, j, j - 1);
                    }
                }
            }
        }

        def calculateMinCost() {
            isVisited = {};

            minCost = 0;
            minCostTree = [];
            for (edge in edgeList) {
                if (isVisited[edge["dest"]] == 0 || isVisited[edge["source"]] == 0) {
                    minCost = minCost + edge["weight"];
                    isVisited[edge["dest"]] = 1;
                    isVisited[edge["source"]] = 1;
                    minCostTree = minCostTree + edge;
                }
            }

            return minCost;
        }


        sort(edgeList, lambda(e1, e2) { return e1["weight"] < e2["weight"]; });

        return calculateMinCost();
    }


    def main() {
        e1 = newEdge(1, 3, 4);
        e2 = newEdge(3, 4, 7);
        e3 = newEdge(4, 2, 6);
        e4 = newEdge(3, 2, 5);
        e5 = newEdge(1, 2, 3);

        edgeList = [e1, e2, e3, e4, e5];
        print("Minimum Cost spanning tree algorithm implementation in krypton");
        print("Minimum Cost -> " + minCost_Kruskal(edgeList, 4));

    }

    main();


}

